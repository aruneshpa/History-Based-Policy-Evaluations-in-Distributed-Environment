import sys
import time
import random
import logging
import configparser
import xml.etree.ElementTree as ET

# Data Structure for Request
class Request:
    def __init__(self, sub_id, res_id, h, sub_attrs=None, res_attrs = None, action=None):
        self.sub_id = sub_id
        self.res_id = res_id
        self.timestamp = time.time()
        self.sub_attrs = []
        self.res_attrs = []
        self.app_id = None
        self.sub_attrs_to_update = []
        self.res_attrs_to_update = []
        self.hashMap = h
        self.action = action

# Data Structure for Rules
class Rule:
    def __init__(self, rulename, sub_id, res_id, action, sub_attrs, res_attrs, sub_attrs_to_update, res_attrs_to_update):
        self.rulename = rulename
        self.sub_id = sub_id
        self.res_id = res_id
        self.sub_attrs = sub_attrs
        self.res_attrs = res_attrs
        self.action = action
        self.sub_attrs_to_update = sub_attrs_to_update
        self.res_attrs_to_update = res_attrs_to_update

#Process Application
class Application(process):
    def setup(hashMap:dict, sub_co:set, res_co:set, master_id: Master):
        pass

    def run():
        #Read Sub_ID and Red_ID from config file. Create an object of Request
        app_config = configparser.ConfigParser()
        app_config.read('request.config')

        app_section = app_config['Application']
        sub_id = app_section['sub_id']
        res_id = app_section['res_id']
        sub_attrs = app_section['sub_attrs']
        res_attrs = app_section['res_attrs']
        action = app_section['action']

        req = Request(sub_id, res_id, hashMap, sub_attrs, res_attrs, action)
        # You need the App Id to return the decision to the App.
        req.app_id = self.id

        #Read the subject Coordinator from the config file
        # or something like
        # sub_coord_id = hash(sub_id)
        # take arg for now
        logging.info("Application sending Req to Sub_Co " + str(req.hashMap[sub_id]))
        send(("evalRequestFromApp", req), to=req.hashMap[sub_id])
        await(len(listof(p,received(('done',), from_=p))) == 1)

    def receive(msg=('policyDecisionFromSub_Co', decision), from_= sub_coord_id):
        logging.info("Received Policy decision from Sub_Co at App-> " + str(self.id))
        if decision== "Success":
            output("Policy Evaluated")
        send(('okay',), to=master_id)

class Sub_Co(process):
    def setup():
        self.procs = dict()
        self.app_id = None
        self.updated_cache = dict()
        self.has_read_from_tent = []
        self.tent_updated_attrs = {}    # dict of str and dict
                                        # 'Attr1':{'Val':value, 'Time':timestamp}
    def run():
        await(len(listof(p,received(('done',), from_=p))) == 1)

    def receive(msg=('evalRequestFromApp', req), from_= app_id):
        # Mark yourself as running. So as it is easy to check whether you were restarted later.
        logging.info("Received Eval Req from App at Sub_Co-> " + str(self.id))
        self.procs[req] = "Running"
        self.app_id = app_id
        # Get the Attributes needed (Only reqd ones, not all of them) from the config file.
        req.sub_attrs = {"history":"empty"}
        req.res_attrs = {}

        # check if those attributes in recent and then tent
        # update the request accordingly
        for attr in req.sub_attrs:
            if attr in updated_cache:
                req.sub_attrs[attr] = updated_cache[attr]
        for attr in req.sub_attrs:
            if attr in tent_updated_attrs:
                req.sub_attrs[attr] = tent_updated_attrs[attr]['value']
        # for attr in req.sub_attrs:
        #     for a in tent_updated_attrs:
        #         if attr in a:
        #             req.sub_attrs[attr] = tent_updated_attrs[a][attr]
        #             has_read_from_tent.append(req)
        # Find the resource Coordinator from config file or hash
        logging.info("Request Updated with Tent and Cache")
        logging.info("Final Req Object is-> " + str(req))
        logging.info("Sub_Co Sending Eval Request to Res_Co-> " + str(req.hashMap[req.res_id]))
        send(('evalRequestFromSub_Co', req), to=req.hashMap[req.res_id])

        # When the decision arrives
    def receive(msg=('decisionFromWorker', req), from_= w_id):
        logging.info("Decision from Worker Recvd at-> " + str(self.id))
        logging.info("Sub obligations-> " + str(req.sub_attrs_to_update))
        logging.info("Res obligations-> " + str(req.res_attrs_to_update))
        # Check Subject Conflict here
        conflict = None
        if req.sub_attrs_to_update:
            for attr in req.sub_attrs_to_update:
                for attr in tent_updated_attrs:
                    if tent_updated_attrs[attr]['timestamp'] > req.timestamp:
                    # If someone has updated tent after you read from it
                        # Conflict
                        conflict = "Present"
                        # Cleanup and Restart
                        procs[self.id] = "Restarted"
                        # Restart Code
                        logging.info("Subject Conflict Found. Restart-> " + str(self.id))
                        send(('evalRequestFromApp', req), to = req.app_id)
                        break

        if conflict != "Present":
            logging.info("Subject Conflict-> Absent.")
            if req.sub_attrs_to_update:
                for attr in req.sub_attrs_to_update:
                    # If you are here, No subject Conflict. Add to tent. (Step 9)
                    if attr in tent_updated_attrs:
                        tent_updated_attrs[attr]['value'] = req.sub_attrs_to_update[attr]
                        tent_updated_attrs[attr]['timestamp'] = req.timestamp
                    else:
                        # New Entry
                        val = req.sub_attrs_to_update[attr]
                        ts = req.timestamp
                        tent_updated_attrs[attr] = dict()
                        tent_updated_attrs[attr]['value'] = val
                        tent_updated_attrs[attr]['timestamp'] = ts
        logging.info("Updated the tent_attr")
        logging.info("Sending Req for Res Conflict eval to Res_Co-> " + str(req.hashMap[req.res_id]))
        # Check for Res Conflict
        send(('conflictEvalRequestFromSub_Co', req), to=req.hashMap[req.res_id])

    def receive(msg=('conflictEvalReplyFromRes_Co', conflict_decision, req), from_= res_coord_id):
        logging.info("Received Conflict eval reply from Res_Co at-> " + str(self.id))
        if conflict_decision == "Present":
            # Resource Conflict
            logging.info("Resource Conflict was found at Res_Co.")
            for r in has_read_from_tent:
                if r.timestamp > req.timestamp:
                    # Cleanup
                    # Check if any the tent_updated_attrs was updated by
                    # Any of these. If yes, revert back.
                    logging.info("Clearing Adminstration for request-> " + str(r))
                    for attr in r.sub_attrs:
                        if attr in tent_updated_attrs:
                            if tent_updated_attrs[attr]['timestamp'] == r.timestamp:
                                del tent_updated_attrs[attr]
                    logging.info("Restarting request " + str(r))
                    send(('evalRequestFromApp', r), to=self.id)
            # Restart yourself
            logging.info("Clearing Adminstration for request-> " + str(req))
            for attr in req.sub_attrs:
                if attr in tent_updated_attrs:
                    if tent_updated_attrs[attr]['timestamp'] == req.timestamp:
                        del tent_updated_attrs[attr]
            logging.info("Restarting request-> " + str(req))
            send(('evalRequestFromApp', req), to=self.id)
        else:
            # No Conflict
            # Add to Cache and Commit
            logging.info("No Conflict. Going to Commit.")
            if req.sub_attrs_to_update:
                for attr in req.sub_attrs_to_update:
                #Commit
                    updated_cache[attr] = req.sub_attrs_to_update[attr]
            logging.info("Sending Policy Decision from Sub_Co to App-> " + str(self.app_id))
            send(('policyDecisionFromSub_Co', "Success"), to=self.app_id)

class Res_Co(process):
    def setup(workers:set):
        self.ongoingEvals = []
        self.updated_cache = {}

    def run():
        await(len(listof(p,received(('done',), from_=p))) == 1)

    def receive(msg=('evalRequestFromSub_Co', req), from_= sub_coord_id):
        logging.info("Request from Sub_Co recvd at-> " + str(self.id))

        #Append this request to Ongoing Evals
        ongoingEvals.append(req)

        #Update the ongong attributes with the list of committed ones.
        for attr in req.res_attrs:
            if attr in updated_cache:
                req.res_attrs[attr] = updated_cache[attr]

        # Get the worker ID from list of workers
        workers_list = [p for p in workers]
        w_id = workers_list[random.randint(0,len(workers_list)-1)]

        logging.info("Sending Request from Res_Co Worker-> " + str(w_id))
        send(('evalRequestFromRes_Co', req), to=w_id)

    def receive(msg=('conflictEvalRequestFromSub_Co', req), from_ = sub_coord_id):
        conflict_decision = None
        logging.info("Received Req for Res Conflict eval at-> " + str(self.id))
        if req.res_attrs_to_update:
            for attr in req.res_attrs_to_update:
                if attr in updated_cache:
                    if updated_cache[attr]['timestamp'] > req.timestamp:
                        conflict_decision = "Present"
                        # Someone Wrote on top of the value that you read. Conflict:
                        break
        if conflict_decision == "Present":
            # Restart
            logging.info("Resource Conflict-> Present")
            logging.info("Send Conflict msg to Sub_Co-> " + str(sub_coord_id))
            send(('conflictEvalReplyFromRes_Co', conflict_decision, req), to=sub_coord_id)
        else:
            # Commit to Cache
            logging.info("No Conflict")
            if req.sub_attrs_to_update:
                for attr in req.res_attrs_to_update:
                    logging.info("Updating the Cache")
                    updated_cache[attr] = req.res_attrs_to_update[attr]
            logging.info("Send No Conflict msg to Sub_Co-> " + str(sub_coord_id))
            send(('conflictEvalReplyFromRes_Co', conflict_decision, req), to=sub_coord_id)


class Worker(process):
    def setup():
        self.rules = []

    def create_rules(filename):
    ###
    #This function reads the policy xml file and craetes a list of rules
    #Which will be used by the worker for further policy evaluation.
    ###
        tree = ET.parse(filename)
        root = tree.getroot()
        rules = []
        for rule in root.iter('rule'):
            sub_attrs = {}
            res_attrs = {}
            action = {}
            sub_attrs_to_update = {}
            res_attrs_to_update = {}

            rule_name = rule.attrib['name']
            sc=rule.find('subjectCondition')
            sub_id = sc.attrib['position']
            for key in sc.attrib.keys():
                if key != 'position':
                    sub_attrs[key] = sc.attrib[key]

            rc=rule.find('resourceCondition')
            if "id" in rc.attrib.keys():
                res_id = rc.attrib['id']
            else:
                res_id = rc.attrib['type']
            for key in rc.attrib.keys():
                if key != 'id' and key != 'type':
                    res_attrs[key] = rc.attrib[key]

            act=rule.find('action')
            for key in act.attrib.keys():
                action = act.attrib[key]

            su=rule.find('subjectUpdate')
            if su != None:
                for key in su.attrib.keys():
                    sub_attrs_to_update[key] = su.attrib[key]
            ru=rule.find('resourceUpdate')
            if ru != None:
                for key in ru.attrib.keys():
                    res_attrs_to_update[key] = ru.attrib[key]
            # Create an object of the Rule Class. Append it to the rules list
            temp_rule = Rule(rule_name, sub_id, res_id, action, sub_attrs, res_attrs, sub_attrs_to_update, res_attrs_to_update)
            rules.append(temp_rule)
        return rules

    def policy(req):
    ###
    #This Routine evaluated the policy based on the rules read from the
    #policy.xml file.
    ###
        for rule in self.rules:
            if (rule.sub_id == req.sub_id and rule.res_id == req.res_id and
              rule.action == req.action and str(rule.sub_attrs) == str(req.sub_attrs) and
              str(rule.res_attrs) == str(req.res_attrs)):
                logging.info("Found a Matching Rule")
                return rule.sub_attrs_to_update, rule.res_attrs_to_update
        return None, None

    def run():
        self.rules = create_rules('policy-example.xml')
        await((len(listof(p,received(('done',), from_=p))) == 1))

    def receive(msg=('evalRequestFromRes_Co', req), from_= res_coord_id):
        logging.info("Received Request from Res_Co at-> " + str(self.id))
        # See if this request has the attributes.
        # If not, got to the DB and fetch. If yes, evaluate on the same attrs
        if req.sub_attrs is None:
            #Get from the DB and set it to req.sub_attrs
            pass
        if req.res_attrs is None:
            #Get from the DB and set it to req.res_attrs
            pass
        (sub_attrs_to_update, res_attrs_to_update) = policy(req)
        req.sub_attrs_to_update = sub_attrs_to_update
        req.res_attrs_to_update = res_attrs_to_update
        logging.info("Sending Decision from Worker to Sub_Co-> " + str(req.hashMap[req.sub_id]))
        send(('decisionFromWorker', req), to=req.hashMap[req.sub_id])


class DB_Emulator(process):
    def setup():
        self.sub_attr_dict = dict()             # Dict to hold the subject:attribute mapping
        self.res_attr_dict = dict()             # Dict to hold the resource:attribute mapping
    def run():
        ###
        #   Here we read from the DB_Config file to upload the attributes in the DB
        #   Only for the first time though.
        ###
        config = configparser.ConfigParser()
        config.read('dbconfig.config')

        sub_section = config["Subject"]
        sub_id = sub_section['sub_id']
        sub_attrs = sub_section['sub_attrs']
        self.sub_attr_dict[sub_id] = sub_attrs       # It has form - SubName : {Attr1:Value, Attr2:Value}

        res_section = config["Resource"]
        res_id = res_section['res_id']
        res_attrs = res_section['res_attrs']
        self.res_attr_dict[res_id] = res_attrs      # It has form - ResName : {Attr1:Value, Attr2:Value}
        await(False)

    def receive(msg=('getSubAttrs', sub_attrs, sub_id), from_= p):
    ###
    #    This routine returns the sub_attrs corresponding to
    #    the sub_id
    ###
        send(('subAttrsFromDB', self.sub_attr_dict[sub_id]), to=p)

    def receive(msg=('getSubAttrs', sub_attrs, sub_id), from_= p):
    ###
    #    This routine returns the res_attrs corresponding to
    #    the res_id
    ###
        send(('resAttrsFromDB', self.res_attr_dict[res_id]), to=p)

class Master(process):
    def setup(config_file_name:str):
        pass

    def run():
        config = configparser.ConfigParser()
        config.read(config_file_name)
        output(str(config.sections()))

        master_section = config['Master']
        num_of_workers = int(master_section['num_of_workers'])
        num_of_sub_co =  int(master_section['num_of_sub_co'])
        num_of_res_co =  int(master_section['num_of_res_co'])
        num_of_clients = int(master_section['num_of_clients'])
        num_of_requests = int(master_section['num_of_request'])

        hashMap = {}
        sub_id = "employee"
        res_id = "bank A"
        worker = new(Worker, [], num = num_of_workers)
        sub_co = new(Sub_Co, [], num = num_of_sub_co)
        res_co = new(Res_Co, [worker], num = num_of_res_co)
        sub_co_list = [p for p in sub_co]
        res_co_list = [p for p in res_co]
        hashMap[sub_id] = sub_co_list[random.randint(0,len(sub_co_list)-1)]
        hashMap[res_id] = res_co_list[random.randint(0,len(res_co_list)-1)]
        app = new(Application, [hashMap, sub_co, res_co, self.id], num = num_of_clients)

        start(app| sub_co | res_co | worker)

        await(len(listof(p,received(('okay',), from_=p))) == num_of_requests)
        send(('done',), to=(app|sub_co|res_co|worker))

def main():
    logging.getLogger('').handlers = []

    logging.basicConfig(
    filename = "policy_eval.log",
    filemode="w",
    level = logging.INFO)

    config_file_name = 'request.config'    # take the file name from the user for different test cases

    # reading input from the config file
    master = new(Master,[config_file_name], num=1)

    start(master)
